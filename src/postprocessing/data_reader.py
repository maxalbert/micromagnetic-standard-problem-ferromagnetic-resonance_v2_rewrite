import numpy as np
from pathlib import Path

from . import util


class BaseDataReader(object):
    """
    This class encapsulates the reading of raw simulation data from
    a data directory. It provides a unified interface to the output
    generated by various micromagnetic simulation softwares (e.g.
    OOMMF, Nmag) which store their simulation output in different
    formats.
    """

    def __init__(self, data_dir):
        self.data_dir = Path(data_dir)
        self.data_avg = self._read_average_magnetisation_data()

    def get_timesteps(self, unit='s'):
        """
        Return a 1D numpy array containing the timesteps at which
        the magnetisation was saved during the simulation.

        The argument `unit` can either be 's' (= seconds) or 'ns'
        (= nanoseconds).
        """
        # Timestamps are contained in the first column of the averaged data
        timesteps = self.data_avg[:, 0]
        return util.convert_to_unit(timesteps, unit)

    def get_dt(self, unit='s'):
        """
        Return float representing the timestep used during the simulation.
        Note that this assumes that all timesteps are equal.

        The argument `unit` can either be 's' (= seconds) or 'ns' (= nanoseconds).
        """
        timesteps = self.get_timesteps(unit)
        return timesteps[1] - timesteps[0]

    def get_num_timesteps(self):
        """
        Return number of timesteps at which the magnetisation was saved
        during the simulation.
        """
        return len(self.get_timesteps())

    def get_average_magnetisation(self, component):
        """
        Return a 1D numpy array containing the values of the
        spatially averaged magnetization sampled at the time-
        steps during the simulation.
        """
        idx = util.get_index_of_m_avg_component(component)
        return self.data_avg[:, idx]

    def get_spatially_resolved_magnetisation(self, component):
        """
        Return a 3D numpy array containing the values of the spatially
        resolved magnetization for the given magnetisation component
        at all timesteps. The magnetisation is sampled on a regular
        grid of size 24 x 24 in the center of the nano-film so that
        the shape of the returned array is (N, 24, 24), where N is the
        number of timesteps present in the simulation.
        """
        return self._read_spatially_resolved_magnetisation_data(component)

    def _read_average_magnetisation_data(self):
        raise NotImplementedError(
            "Data reader of type '{}' does not implement reading of "
            "spatially averaged magnetisation data.".format(self.__class__.__name__))

    def _read_spatially_resolved_magnetisation_data(self, component):
        raise NotImplementedError(
            "Data reader of type '{}' does not implement reading of "
            "spatially resolved magnetisation data.".format(self.__class__.__name__))


class OOMMFDataReader(BaseDataReader):
    def _read_average_magnetisation_data(self):
        filename = str(self.data_dir.joinpath('dynamic_txyz.txt'))
        return np.loadtxt(filename)

    def _read_spatially_resolved_magnetisation_data(self, component):
        filename = str(self.data_dir.joinpath('m{}s.npy'.format(component)))
        m = np.load(filename)
        return m.reshape(-1, 24, 24)


class NmagDataReader(BaseDataReader):
    def _read_average_magnetisation_data(self):
        data_avg_filename = str(self.data_dir.joinpath('dynamic_txyz.txt'))
        return np.loadtxt(data_avg_filename)

    def _read_spatially_resolved_magnetisation_data(self, component):
        filename = str(self.data_dir.joinpath('m{}s.npy'.format(component)))
        m = np.load(filename)
        return m.reshape(-1, 24, 24)


#
# If you want to support additional data formats then you need to
# create a new subclass of DataReader (similar to OOMMFDataReader and
# NmagDataReader above) and add it to `data_reader_classes`.
#
data_reader_classes = {
    'OOMMF': OOMMFDataReader,
    'Nmag': NmagDataReader,
    }


def DataReader(data_path, data_format):
    """
    """
    try:
        cls = data_reader_classes[data_format]
    except KeyError:
        supported_data_formats = list(data_reader_classes.keys())
        raise ValueError(
            ("Unsupported data format: '{}'. Supported values: {} "
             "".format(data_format, supported_data_formats)))

    return cls(data_path)
